# AUTOGENERATED! DO NOT EDIT! File to edit: 01_fuzzifiers.ipynb (unless otherwise specified).

__all__ = ['Fuzzifier', 'CrispFuzzifier', 'LinearFuzzifier']

# Cell

import numpy as np
import matplotlib.pyplot as plt
import pytest
from scipy.optimize import curve_fit

# Cell

class Fuzzifier:
    def __init__(self, xs=None, mus=None):
        self.xs = xs
        self.mus = mus

    def get_r_to_mu(self,
                    sq_radius, # was SV_square_distance
                    x_to_sq_dist): # was estimated_square_distance_from_center
        '''Transforms the square distance between center of the learnt sphere
        and the image of a point in original space into the membership degree
        of the latter to the induced fuzzy set.

        Not implemented in the base fuzzifier class.

        - `sq_radius`: squared radius of the learnt sphere (float).

        - `x_to_sq_dist`: mapping of a point in original space into the
          square distance of its image from the center of the learnt sphere
          (function).
        '''

        raise NotImplementedError(
        'the base class does not implement get_r_to_mu method')

    def get_fuzzified_membership(self,
                                 sq_radius, # was SV_square_distance
                                 x_to_sq_dist, # was estimated_square_distance_from_center
                                 return_profile=False):
        '''Return the induced membership function.

        - `sq_radius`: squared radius of the learnt sphere (float).

        - `x_to_sq_dist`: mapping of a point in original space into the
          square distance of its image from the center of the learnt sphere
          (function).

        - `return_profile` flag triggering the generation of the graph
          of the fuzzifier to be returned alongside the fuzzifier itself
          (bool, default=False).

        Returns a list containing

        - the membership function if `return_profile` is `False`, and
        - the membership function and the salient coordinates of the graph of
          the fuzzifier if `return_profile` is `True`.
        '''
        r_to_mu = self.get_r_to_mu(sq_radius, x_to_sq_dist)

        def estimated_membership(x):
            r = x_to_sq_dist(np.array(x))
            return r_to_mu(r)

        result = [estimated_membership]

        if return_profile:
            rdata = list(map(x_to_sq_dist, self.xs))
            rdata_synth = np.linspace(0, max(rdata)*1.1, 200)
            estimate = list(map(r_to_mu, rdata_synth))
            result.append([rdata, rdata_synth, estimate])

        return result

    def __str__(self):
        return self.__repr__()

    def __eq__(self, other):
        return type(self) == type(other)

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash(self.__repr__())

    def __nonzero__(self):
        return True

# Cell

class CrispFuzzifier(Fuzzifier):
    def __init__(self, xs=None, mus=None, profile='fixed'):
        r'''Creates an instance of `CrispFuzzifier`

        - `xs`: objects in training set (iterable).

        - `ys`: degree memberships in training set (iterable).

        - `profile`: method to be used in order to fix the fuzzifier
          threshold ('fixed' used the sphere radius, 'infer' fits using
          data in `self.xs` and `self.mus`.
        '''

        super().__init__(xs, mus)
        self.profile = profile
        if profile not in ['fixed', 'infer']:
            raise ValueError(f"'profile' parameter should be equal to "
                             "'fixed' or 'infer' (provided value: {profile})")

        if profile == 'infer' and (xs is None or mus is None):
            raise ValueError(f"all arguments to the constructor of "
                             "CrispFuzzifier should be specified when "
                             "profile='infer'")

        self.name = 'Crisp'
        self.latex_name = '$\\hat\\mu_{\\text{crisp}}$'

    def get_r_to_mu(self, sq_radius, x_to_sq_dist):
        r'''Returns a function that transforms the square distance between
        center of the learnt sphere and the image of a point in original
        space into a crisp membership degree having the form

        $$ \mu(r) = \begin{cases}
          1 & \text{if $r \leq r_\text{crisp}$,} \\
          0 & \text{otherwise.}
        \end{cases}$$

        The threshold is set to the learnt square radius of the sphere if the
        `profile` attribute of the class have been set to `fixed`, and
        induced via interpolation of the `xs` and `mus` attributes when it is
        has been set to `infer`.

        **Note** This function is meant to be called internally by the
        `get_fuzzified_membership` method in the base `Fuzzifier` class.

        - `sq_radius`: squared radius of the learnt sphere (float).

        - `x_to_sq_dist`: mapping of a point in original space into the
          square distance of its image from the center of the learnt sphere
          (function).
        '''

        if self.profile == 'fixed':
            return lambda r: 1 if r <= sq_radius else 0

        elif self.profile == 'infer':
            rdata = np.fromiter(map(x_to_sq_dist, self.xs), dtype=float)

            def r_to_mu_prototype(r, r_crisp):
                result = np.ones(len(r))
                result[r > r_crisp] = 0
                return result


            popt, _ = curve_fit(r_to_mu_prototype, rdata, self.mus)
                                # bounds=((0,), (np.inf,)))

            if popt[0] < 0:
                raise ValueError('Profile fitting returned a negative parameter')
            return lambda r: r_to_mu_prototype([r], *popt)[0]
        else:
            raise ('This should never happen. '
                   'Check CrispFuzzifier constructor.')

    def __repr__(self):
        xs_repr = self.xs.__repr__()
        mus_repr = self.mus.__repr__()
        self_repr = f'CrispFuzzifier({xs_repr}, {mus_repr}'
        if self.profile != 'fixed':
            self_repr += f', profile={self.profile}'
        self_repr += ')'
        return self_repr

# Cell

class LinearFuzzifier(Fuzzifier):
    def __init__(self, xs=None, mus=None, profile='infer'):
        r'''Creates an instance of `LinearFuzzifier`

        - `xs`: objects in training set (iterable).

        - `ys`: degree memberships in training set (iterable).

        - `profile`: method to be used in order to fix the fuzzifier
          threshold ('fixed' used the sphere radius, 'infer' fits using
          data in `self.xs` and `self.mus`.
        '''

        super().__init__(xs, mus)

        if profile not in ['fixed', 'infer']:
            raise ValueError(f"'profile' parameter should be equal to "
                             "'fixed' or 'infer' (provided value: {profile})")
        self.profile = profile

        self.name = 'Linear'
        self.latex_name = '$\\hat\\mu_{\\text{lin}}$'


    def get_r_to_mu(self, SV_square_distance, sample,
                    estimated_square_distance_from_center):
        '''Maps distance from center to membership.
           If self.profile='infer' this is done fitting a function
           having the form r -> 1 if r < r_crisp else l(r) where l
           is a linear decreasing function clipped to zero.
           If self.profile='fixed' l is bounded to contain the
           point (SV_square_distance, 0.5).'''


        rdata = np.fromiter(map(estimated_square_distance_from_center,
                                self.xs),
                            dtype=float)

        r_1_guess = np.median([estimated_square_distance_from_center(x)
                               for x, mu in zip(self.xs, self.mus)
                               if mu>=0.99])

        if self.profile == 'fixed':
            def r_to_mu_prototype(r, r_1):
                def r_to_mu_single(rr):
                    r_05 = SV_square_distance
                    res = 1 - 0.5 * (rr - r_1) / (r_05 - r_1)
                    if rr < r_1:
                        return 1
                    elif res < 0:
                        return 0
                    else:
                        return res

                return [r_to_mu_single(rr) for rr in r]

            popt, _ = curve_fit(r_to_mu_prototype,
                                rdata, self.mus,
                                p0=(r_1_guess,),
                                bounds=((0,), (np.inf,)))
        elif self.profile == 'infer':
            def r_to_mu_prototype(r, r_1, r_0):
                def r_to_mu_single(rr):
                    res = 1 - (r_1 - rr) / (r_1 - r_0)
                    if rr < r_1:
                        return 1
                    elif rr > r_0:
                        return 0
                    else:
                        return res
                return [r_to_mu_single(rr) for rr in r]

            popt, _ = curve_fit(r_to_mu_prototype,
                                rdata, self.mus,
                                p0=(r_1_guess, 10*SV_square_distance),
                                bounds=((0, 0), (np.inf, np.inf,)))
        else:
            raise ValueError('This should never happen.'
                             ' Check LinearFuzzifier constructor.')
        if min(popt) < 0:
            raise ValueError('Profile fitting returned a negative parameter')

        return lambda r: r_to_mu_prototype([r], *popt)[0]



    def __repr__(self):
        return "LinearFuzzifier({}, {}, profile='{}')".format(self.xs, self.mus, self.profile)

    def __str__(self):
        return self.__repr__()

    def __eq__(self, other):
        return type(self) == type(other)

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash(self.__repr__())

    def __nonzero__(self):
        return True