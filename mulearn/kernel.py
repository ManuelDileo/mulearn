# AUTOGENERATED! DO NOT EDIT! File to edit: 00_kernel.ipynb (unless otherwise specified).

__all__ = ['Kernel', 'LinearKernel', 'PolynomialKernel', 'HomogeneousPolynomialKernel', 'GaussianKernel']

# Cell

import numpy as np
import pytest

# Cell

class Kernel(object):

    def __init__(self):

        self.precomputed = False

    def compute(self, arg_1, arg_2):

        raise NotImplementedError(
            'this class does not implement the compute method')

    @classmethod
    def get_default(cls):
        r'''Return the default kernel.
        '''

        return LinearKernel()


# Cell

class LinearKernel(Kernel):

    def compute(self, arg_1, arg_2):
        r'''
        Compute the dot product between `arg_1` and `arg_2`, where the
        dot product $x \cdot y$ is intended as the quantity
        $\sum_{i=1}^n x_i y_i$, $n$ being the dimension of both
        $x$ and $y$.

        - `arg_1`: first dot product argument (iterable).

        - `arg_2`: second dot product argument (iterable).

        Returns: kernel value (float).'''

        return float(np.dot(arg_1, arg_2))

    def __repr__(self):
        return 'LinearKernel()'

    def __str__(self):
        return self.__repr__()

    def __eq__(self, other):
        return type(self) == type(other)

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash('LinearKernel')

    def __nonzero__(self):
        return True

# Cell

class PolynomialKernel(Kernel):

    def __init__(self, degree):
        r'''Creates an instance of `PolynomialKernel`

        - `degree`: degree of the polynomial kernel (positive integer).
        '''

        Kernel.__init__(self)
        if degree > 0 and isinstance(degree, int):
            self.degree = degree
        else:
            raise ValueError(str(degree) +
                ' is not usable as a polynomial degree')

    def compute(self, arg_1, arg_2):
        r'''
        Compute the polynomial kernel between `arg_1` and `arg_2`,
        where the kernel value $k(x_1, x_2)$ is intended as the quantity
        $(x_1 \cdot x_2 + 1)^d$, $d$ being the polynomial degree of
        the kernel.

        - `arg_1` first argument to the polynomial kernel (iterable).

        - `arg_2` second argument to the polynomial kernel (iterable).

        Returns: kernel value (float)
        '''

        return float((np.dot(arg_1, arg_2) + 1) ** self.degree)

    def __repr__(self):
        return 'PolynomialKernel(' + repr(self.degree) + ')'

    def __str___(self):
        return self.__repr__()


# Cell

class HomogeneousPolynomialKernel(Kernel):

    def __init__(self, degree):
        r'''Creates an instance of `HomogeneousPolynomialKernel`.

        - `degree`: polynomial degree (positive integer).
        '''

        Kernel.__init__(self)
        if degree > 0 and isinstance(degree, int):
            self.degree = degree
        else:
            raise ValueError(str(degree) +
                ' is not usable as a polynomial degree')

    def compute(self, arg_1, arg_2):
        r'''
        Compute the homogeneous polynomial kernel between `arg_1` and
        `arg_2`, where the kernel value $k(x_1, x_2)$ is intended as
        the quantity $(x_1 \cdot x_2)^d$, $d$ being the polynomial
        degree of the kernel.

        - `arg_1`: first argument to the homogeneous polynomial kernel
          (iterable).

        - `arg_2`: second argument to the homogeneous polynomial kernel
          (iterable).

        Returns: kernel value (float).
        '''

        return float(np.dot(arg_1, arg_2) ** self.degree)

    def __repr__(self):
        return 'HomogeneousPolynomialKernel(' + repr(self.degree) + ')'

    def __str___(self):
        return self.__repr__()

# Cell

class GaussianKernel(Kernel):

    def __init__(self, sigma=1):
        r'''
        Creates an instance of `GaussianKernel`.

        - `sigma`: gaussian standard deviation (positive float).
        '''

        Kernel.__init__(self)
        if sigma > 0:
            self.sigma = sigma
        else:
            raise ValueError(f'{sigma} is not usable '
                             'as a gaussian standard deviation')

    def compute(self, arg_1, arg_2):
        r'''
        Compute the gaussian kernel between `arg_1` and `arg_2`,
        where the kernel value $k(x_1, x_2)$ is intended as the quantity
        $\mathrm e^{-\frac{||x_1 - x_2||^2}{2 \sigma^2}}$, $\sigma$
        being the kernel standard deviation.

        - `arg_1`: first argument to the gaussian kernel (iterable).

        - `arg_2`: second argument to the gaussian kernel (iterable).

        Returns: kernel value (float).
        '''

        diff = np.linalg.norm(np.array(arg_1) - np.array(arg_2)) ** 2
        return float(np.exp(-1. * diff / (2 * self.sigma ** 2)))

    def __repr__(self):
        return 'GaussianKernel(' + repr(self.sigma) + ')'

    def __str___(self):
        return self.__repr__()